package optimizationProblem;

import java.util.ArrayList;
import java.util.HashMap;

public class GeneticAlgorithm {
	
	public static double[][] distance; // 距离矩阵  
    public final static int SPECIES_NUM=200; //种群数
    //private int cityNum; // 城市数量，染色体长度  
    private int MAX_GEN = 1000; // 进化代数  
    int beginIndex;
    private int[] gene;
    private ArrayList<Chromosome> population;//种群
   
     /*private int bestT;// 最佳出现代数  
    private int bestLength; // 最佳长度  
    private int[] Route; // 最佳路径  
    
    // 初始种群，父代种群，行数表示种群规模，一行代表一个个体，即染色体，列表示染色体基因片段  
    private int[][] oldPopulation;  
    private int[][] newPopulation;// 新的种群，子代种群  
    private int[] fitness;// 种群适应度，表示种群中各个个体的适应度  
  
    private float[] Pi;// 种群中各个个体的累计概率  
    private float Pc;// 交叉概率  
    private float Pm;// 变异概率  
    private int iteration;// 当前代数  
    
    public GeneticAlgorithm(int scale, int cityNum, float pc, float pm, Route currentRoute) {  
        this.scale = scale;  
        this.cityNum = cityNum;  
        this.Pc = pc;  
        this.Pm = pm;  
        this.init(currentRoute);
    }  */
    
   
    private void init(City[] cities){
    	computeDistanceMap(cities);
    	beginIndex = 0;
    	//生成初始种群(两个祖宗)
    	population = new ArrayList<Chromosome>();
    	gene = new int[cities.length];
    	for(int i = 0; i< cities.length; i++){
    		gene[i] = i;
    	}
    	swap(gene[beginIndex],gene[0]);
    	population.add(new Chromosome(gene));
    	for(int i = 0; i< cities.length; i++){
    		gene[i] = cities.length-i-1;
    	}
    	swap(gene[cities.length-beginIndex-1],gene[0]);
    	population.add(new Chromosome(gene));
    }
    
    private void swap( int i1, int i2){
    	int temp = i1;
    	i1 = i2;
    	i2 = temp;
    }
  
    
    //开始遗传
  	public void run(City[] cities)
  	{
  		//创建初始种群
  		init(cities);
  		
  		for(int i=1;i<=MAX_GEN;i++)
  		{
  			int size = population.size();
  			 for(int x = 0; x < size; x++){//本代个体交配
  				for(int y = x + 1; y < size; y++) {
                    Chromosome child1;
                    Chromosome child2;
                    Crossover(population.get(x),population.get(y),child1,child2);
                    if(child1.Alive())
                    	population.add(child1);
                    if(child2.Alive())
                    	population.add(child2);
                }
  			 }
  		}	
  		
  		
  	}
    
	
	
		
	//交叉操作
	void crossover(Chromosome parent1,Chromosome parent2,
	        Chromosome child1,Chromosome child2)
	{
		 // 选取交叉区间 0 [1-x) [x,y] (y,N-1]
        int y = (int) (Math.random()*(gene.length - 1)) + 1;
        int x = (int) (Math.random()*(y - 1)) + 1;
        int[] gene1 = new int[gene.length];
        int[] gene2 = new int[gene.length];
        HashMap<Integer,Integer> m1 = new HashMap<Integer,Integer>();
        HashMap<Integer,Integer> m2 = new HashMap<Integer,Integer>();
        
        for(int i = x; i <= y; i++) {
        	m1.put(gene1[i], gene2[i]);
            m1.insert(make_pair(gene1[i],gene2[i]));
            m1.insert(make_pair(gene2[i],gene1[i]));
            int temp = gene1[i];
            gene1[i] = gene2[i];
            gene2[i] = temp;
        }
	}
		
	public void computeDistanceMap(City[] cities){
    	for(int i=0;i<cities.length;i++)
		{
			for(int j=i;j<cities.length;j++)
			{
				double dist = cities[i].measureDistance(cities[j]);
				distance[i][j]=dist;
				distance[j][i]=distance[i][j];
			}
		}	
    }	

}
