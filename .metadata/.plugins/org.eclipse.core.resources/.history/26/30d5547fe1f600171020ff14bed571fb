package optimizationProblem;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

public class GeneticAlgorithm {
	
	public static double[][] distance; // 距离矩阵  
    public final static int P_SIZE=200; //种群大小
    //private int cityNum; // 城市数量，染色体长度  
    private int MAX_GEN = 1000; // 进化代数  
    int beginIndex;
    private int[] gene;
    private ArrayList<Chromosome> population;//种群
   
     /*private int bestT;// 最佳出现代数  
    private int bestLength; // 最佳长度  
    private int[] Route; // 最佳路径  
    
    // 初始种群，父代种群，行数表示种群规模，一行代表一个个体，即染色体，列表示染色体基因片段  
    private int[][] oldPopulation;  
    private int[][] newPopulation;// 新的种群，子代种群  
    private int[] fitness;// 种群适应度，表示种群中各个个体的适应度  
  
    private float[] Pi;// 种群中各个个体的累计概率  
    private float Pc;// 交叉概率  
    private float Pm;// 变异概率  
    private int iteration;// 当前代数  
    
    public GeneticAlgorithm(int scale, int cityNum, float pc, float pm, Route currentRoute) {  
        this.scale = scale;  
        this.cityNum = cityNum;  
        this.Pc = pc;  
        this.Pm = pm;  
        this.init(currentRoute);
    }  */
    
   
    private void init(City[] cities){
    	computeDistanceMap(cities);
    	beginIndex = 0;
    	//生成初始种群(两个祖宗)
    	population = new ArrayList<Chromosome>();
    	gene = new int[cities.length];
    	for(int i = 0; i< cities.length; i++){
    		gene[i] = i;
    	}
    	swap(gene[beginIndex],gene[0]);
    	population.add(new Chromosome(gene));
    	for(int i = 0; i< cities.length; i++){
    		gene[i] = cities.length-i-1;
    	}
    	swap(gene[cities.length-beginIndex-1],gene[0]);
    	population.add(new Chromosome(gene));
    	
    	extracted();
    }

	private void extracted() {
		Collections.sort(population);
	}
    
    private void swap( int i1, int i2){
    	int temp = i1;
    	i1 = i2;
    	i2 = temp;
    }
  
    
    //开始遗传
  	public void run(City[] cities)
  	{
  		//创建初始种群
  		init(cities);
  		
  		for(int i=1;i<=MAX_GEN;i++)
  		{
  			int size = population.size();
  			 for(int x = 0; x < size; x++){//本代个体交配
  				for(int y = x + 1; y < size; y++) {
                    Chromosome child1 = new Chromosome();
                    Chromosome child2 = new Chromosome();;
                    crossover(population.get(x),population.get(y),child1,child2);
                    if(child1.Alive())
                    	population.add(child1);
                    if(child2.Alive())
                    	population.add(child2);
                }
  			 }
  		}	
  		
  		
  	}
    
	
	
		
	//交叉操作
	private void crossover(Chromosome parent1,Chromosome parent2,
	        Chromosome child1,Chromosome child2)
	{
		 // 选取交叉区间 0 [1-x) [x,y] (y,N-1]
        int y = (int) (Math.random()*(gene.length - 1)) + 1;
        int x = (int) (Math.random()*(y - 1)) + 1;
        int[] gene1 = parent1.getGene().clone();
        int[] gene2 = parent2.getGene().clone();
        HashMap<Integer,Integer> m1 = new HashMap<Integer,Integer>();
        HashMap<Integer,Integer> m2 = new HashMap<Integer,Integer>();
        
        for(int i = x; i <= y; i++) {
        	m1.put(gene1[i], gene2[i]);
            m2.put(gene2[i],gene1[i]);
            swap(gene1[i], gene2[i]);
        }
        
        for(int i = 0; i <= gene.length - 1; i++) {
            if(i < x || i > y) {
                if(m1.containsKey(gene1[i]))
                    gene1[i] = m1.get(gene1[i]);
                if(m2.containsKey(gene2[i]))
                    gene2[i] =m2.get(gene2[i]);
            }
        }
        
        child1 = new Chromosome(gene1);
        child2 = new Chromosome(gene2);
	}
	
	

		
	public void computeDistanceMap(City[] cities){
    	for(int i=0;i<cities.length;i++)
		{
			for(int j=i;j<cities.length;j++)
			{
				double dist = cities[i].measureDistance(cities[j]);
				distance[i][j]=dist;
				distance[j][i]=distance[i][j];
			}
		}	
    }	

}
