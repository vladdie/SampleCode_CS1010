package optimizationProblem;

import java.util.Random;

public class Species {
	
	private Route genes;//基因序列
	double distance;//路程
	double fitness;//适应度
	Species next;
	double rate;

	public Species(Route route)
	{
		//初始化
		this.genes = route;
		this.fitness = 0.0;
		this.distance = 0.0;
		this.next = null;
		this.rate = 0.0;
	}
	
	//初始物种基因(随机)
	void createByRandomGenes()
	{
		//获取随机种子
		Random rand=new Random();

		for(int j = 0;j < genes.getCities().size();j++)
		{
			int num= j + rand.nextInt(genes.getCities().size()-j);	
			//交换
			City tmp;
			tmp = genes.getCities().get(num);
			genes.getCities().set(num, genes.getCities().get(j));
			genes.getCities().set(j, tmp);
		}
	}
	
	//初始物种基因(贪婪)
	void createByGreedyGenes()
	{
		Random rand=new Random();
		int i= rand.nextInt(genes.getCities().size()); //随机产生一个城市作为起点
		int[] tempRoute = new int[genes.getCities().size()];  
		tempRoute[0]=i;
		int j;//终点
		int cityNum=0;
		do
		{
			cityNum++;
			
			//选出单源最短城市
			double minDis=Integer.MAX_VALUE;
			int minCity=0;
			for(j=0;j<genes.getCities().size();j++)
			{
				if(j != i)
				{
					//判是否和已有重复
					boolean repeat=false;
					for(int n=0;n<cityNum;n++)
					{
						if(tempRoute[n] == j+1)
						{
							repeat=true;//重了
							break;
						}
					}
					if(repeat == false)//没重
					{
						//判长度
						if(GeneticAlgorithm.distance[i][j] < minDis)
						{
							minDis=GeneticAlgorithm.distance[i][j];
							minCity=j;
						}
					}
				}
			}
			
			//加入到染色体
			genes[cityNum]=Integer.toString(minCity+1);
			i=minCity;
		}while(cityNum < genes.getCities().size());
	}
	
	//计算物种适应度
		void calFitness()
		{
			float totalDis=0.0f;
			for(int i = 0;i < Constant.CITY_NUM;i++)
			{
				int curCity=Integer.parseInt(this.genes[i])-1;
				int nextCity=Integer.parseInt(this.genes[(i+1) % Constant.CITY_NUM])-1;

				totalDis += Constant.disMap[curCity][nextCity];
			}
			
			this.distance=totalDis;
			this.fitness=1.0f/totalDis;
		}
}
